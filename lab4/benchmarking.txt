Work: foldP and traverse both iterate over the entire array and produce n work.
Each call to mmax produces k work where k = [1..n] and that produce n(n+1)/2 work.
This gives a total of n + n(n+1)/2 == O(n^2) work.

Span: foldP and traverse have a span of 1 each.
The greatest span of mmax is max(k)=n.
This gives a total of 1+1+n == O(n) span.

In summary, we have w = O(n^2) and d = O(n). This gives a "parallelism" of w/d = O((n^2)/n) = O(n). This means that with enough processors, we would get a running time of O(n).


Tests are run on an array of size 10000 with random integers.

Test machine:
2-core 4-thread
Sequential
benchmarking buySell
time                 1.179 s    (1.126 s .. 1.287 s)
                     0.999 R²   (0.998 R² .. 1.000 R²)
mean                 1.134 s    (1.119 s .. 1.163 s)
std dev              24.60 ms   (0.0 s .. 25.23 ms)

Flags: +RTS -N4 -ls
benchmarking buySell
time                 1.104 s    (1.028 s .. 1.165 s)
                     0.999 R²   (0.999 R² .. 1.000 R²)
mean                 1.106 s    (1.097 s .. 1.113 s)
std dev              10.97 ms   (0.0 s .. 12.27 ms)
